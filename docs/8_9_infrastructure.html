<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Infrastructure - The Node Experiment - Exploring Async Basics with Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="1_concurrent_vs_parallel.html"><strong aria-hidden="true">1.</strong> Concurrent vs Parallel</a></li><li><a href="2_async_history.html"><strong aria-hidden="true">2.</strong> Async history</a></li><li><a href="3_0_the_operating_system.html"><strong aria-hidden="true">3.</strong> The Operating System and CPU</a></li><li><ol class="section"><li><a href="3_1_communicating_with_the_os.html"><strong aria-hidden="true">3.1.</strong> Communicating with the OS</a></li><li><a href="3_2_cross_platform_abstractions.html"><strong aria-hidden="true">3.2.</strong> Writing Cross Platform Abstractions</a></li><li><a href="3_3_the_cpu_and_the_os.html"><strong aria-hidden="true">3.3.</strong> The CPU and the OS</a></li></ol></li><li><a href="4_interrupts_firmware_io.html"><strong aria-hidden="true">4.</strong> Interrupts, Firmware and I/O</a></li><li><a href="5_strategies_for_handling_io.html"><strong aria-hidden="true">5.</strong> Strategies for handling I/O</a></li><li><a href="6_epoll_kqueue_iocp.html"><strong aria-hidden="true">6.</strong> Epoll, Kqueue and IOCP</a></li><li><a href="7_0_introducing_our_main_example.html"><strong aria-hidden="true">7.</strong> Introducing our main example</a></li><li><ol class="section"><li><a href="7_1_what_is_node.html"><strong aria-hidden="true">7.1.</strong> What is Node?</a></li><li><a href="7_2_whats_our_plan.html"><strong aria-hidden="true">7.2.</strong> What's our plan</a></li></ol></li><li><a href="8_0_implementing_our_own_runtime.html"><strong aria-hidden="true">8.</strong> Implementing our own Runtime</a></li><li><ol class="section"><li><a href="8_1_the_main_loop.html"><strong aria-hidden="true">8.1.</strong> Running our runtime - the main loop</a></li><li><a href="8_2_setting_up_runtime.html"><strong aria-hidden="true">8.2.</strong> Setting up our runtime</a></li><li><a href="8_3_timers.html"><strong aria-hidden="true">8.3.</strong> Timers</a></li><li><a href="8_4_callbacks.html"><strong aria-hidden="true">8.4.</strong> Callbacks</a></li><li><a href="8_5_threadpool.html"><strong aria-hidden="true">8.5.</strong> Threadpool</a></li><li><a href="8_6_io_eventqueue.html"><strong aria-hidden="true">8.6.</strong> I/O eventqueue</a></li><li><a href="8_8_cleaning_up.html"><strong aria-hidden="true">8.7.</strong> Cleaning up</a></li><li><a href="8_9_infrastructure.html" class="active"><strong aria-hidden="true">8.8.</strong> Infrastructure</a></li></ol></li><li><a href="9_0_modules.html"><strong aria-hidden="true">9.</strong> Modules</a></li><li><ol class="section"><li><a href="9_1_file_module.html"><strong aria-hidden="true">9.1.</strong> File module</a></li><li><a href="9_2_crypto_module.html"><strong aria-hidden="true">9.2.</strong> Crypto module</a></li><li><a href="9_3_http_module.html"><strong aria-hidden="true">9.3.</strong> Http module</a></li></ol></li><li><a href="10_putting_pieces_together.html"><strong aria-hidden="true">10.</strong> Putting the pieces together</a></li><li><a href="11_final_code.html"><strong aria-hidden="true">11.</strong> Final code</a></li><li><a href="12_shortcuts_and_improvements.html"><strong aria-hidden="true">12.</strong> Shortcuts and improvements</a></li><li class="affix"><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Node Experiment - Exploring Async Basics with Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                            <a href="https://github.com/cfsamson/book-exploring-async-basics" title="Git repository" aria-label="Git repository">
                                <i id="git-repository-button" class="fa fa-github"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#infrastructure" id="infrastructure">Infrastructure</a></h1>
<p>Now, for everything to work we need some helpers to make our infrastructure work.</p>
<p>First of all, we need a way to get the <code>id</code> of an available thread.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
   fn get_available_thread(&amp;mut self) -&gt; usize {
        match self.available_threads.pop() {
            Some(thread_id) =&gt; thread_id,
            // We would normally return None and the request and not panic!
            None =&gt; panic!(&quot;Out of threads.&quot;),
        }
    }
#}</code></pre></pre>
<p>As you see, we take one huge shortcut here. If we run out of threads, we <code>panic!</code>.
This is not good, and we should rather implement logic to queue these requests
and run them as soon as a thread is available. However, our code is already getting
long, and it's not very important for our goal of learning about <code>async</code>.</p>
<p>Maybe this implementing such a queue is a good reader-exercise? Feel free to fork
the repository and go ahead :)</p>
<p>The next thing we need to do is to create an unique identity for our callbacks.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
/// If we hit max we just wrap around
fn generate_identity(&amp;mut self) -&gt; usize {
    self.identity_token = self.identity_token.wrapping_add(1);
    self.identity_token
}

fn generate_cb_identity(&amp;mut self) -&gt; usize {
    let ident = self.generate_identity();
    let taken = self.callback_queue.contains_key(&amp;ident);

    // if there is a collision or the identity is already there we loop until we
    // find a new one. We don't cover the case where there are `usize::max_value()`
    // number of callbacks waiting since that if we're fast and queue a new event
    // every nanosecond that will stilltake 585 years to do on a 64 bit system.
    if !taken {
        ident
    } else {
        loop {
            let possible_ident = self.generate_identity();
            if self.callback_queue.contains_key(&amp;possible_ident) {
                break possible_ident;
            }
        }
    }
}
#}</code></pre></pre>
<p>The function <code>generate_cb_identity</code> is where it all happens, <code>genereate_identity</code> is just
a small function so we try to avoid the long functions we had in the introduction.</p>
<blockquote>
<p>Now, there are some important considerations to be aware of. Even though we use
several threads, we use a regular <code>usize</code> here and the reason for that is that
it's only one thread that will be generating Id's. This could cause problems if
several threads tried to <code>read</code> and <code>generate</code> new Id's at the same time.</p>
</blockquote>
<p>We use the <code>wrapping_add</code> method on <code>usize</code> to get the next Id, this means that
when we reach <code>18446744073709551615</code> we wrap around to 0 again.</p>
<p>We do check of our callback_queue contains our key (even though that is unlikely
by design), and if it's taken we just generate a new one until we find a available
one.</p>
<p>Next up is the method we use to add a callback to our <code>callback_queue</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Adds a callback to the queue and returns the key
fn add_callback(&amp;mut self, ident: usize, cb: impl FnOnce(Js) + 'static) {
    let boxed_cb = Box::new(cb);
    self.callback_queue.insert(ident, boxed_cb);
}
#}</code></pre></pre>
<p>If you haven't seen the signature <code>cb: impl impl FnOnce(Js) + 'static</code> before I'll
explain it briefly here.</p>
<p>The <code>impl ...</code> means that we accept an arguments that implements the trait <code>FnOnce(Js)</code>
with a <code>'static</code> lifetime. <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a> is
a trait implemented by <code>closures</code>. There are three main traits a <code>closure</code> can implement
in Rust and <code>FnOnce</code> is the one you'll use if you plan on consume an instance from
the environment.</p>
<p>Since you consume the variable a <code>closure</code> implementing <code>FnOnce</code> can only be called
once. Our closure will take ownership over resources we create in our <code>main</code> thread
and consume it. We want this since once consumed, the resources we used will be cleaned
up as a result of Rusts <code>RAII</code> pattern. It's implicit that <code>FnOnce</code> returns <code>()</code> in this 
case so we don't have to write <code>FnOnce(Js) -&gt; ()</code>.</p>
<p>Since callbacks are meant to only be called once, this is a perfectly fine bound
for us to use here.</p>
<p>Now, traits doesn't have a size so for the compiler to be able to allocate space
for it on the stack we either need to take a reference <code>&amp;FnOnce(Js)</code> or place it
on the heap using <code>Box</code>. We do the latter since that's the only thing that makes
sense for our use case. Box is a pointer to a heap allocated variable which we do
know the size of so we store that reference in our <code>callback_queue</code> HashMap.</p>
<blockquote>
<p>What makes a closure?
A function in rust can be defined as easily as <code>|| { }</code>. If this is all we write
it's the same as a function pointer, equivalent to just referencing <code>my_method</code> (whithout parenthesis).
It becomes a <code>closure</code> as soon as you &quot;close&quot; over your environment by referencing
variables that's not owned by the <code>function</code>.</p>
<p><code>Fn</code> traits are automatically implemented, and whether it implements <code>Fn</code>, <code>FnMut</code>
or <code>FnOnce</code> depend whether you take ownership over a non-copy variable, take a shared
reference <code>&amp;</code> or an exclusive reference <code>&amp;mut</code> (often called a mutable reference).</p>
</blockquote>
<p>Now that we got some closure basics out of the way we can move on. The next method
is how we register <code>I/O</code> work. This is how we register an <code>epoll</code> event with our runtime:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn register_event_epoll(&amp;mut self, token: usize, cb: impl FnOnce(Js) + 'static) {
    self.add_callback(token, cb);

    print(format!(&quot;Event with id: {} registered.&quot;, token));
    self.pending_events += 1;
    self.epoll_pending_events += 1;
}
#}</code></pre></pre>
<p>The first thing we do is to add the callback to our <code>callback_queue</code>, calling the
method we explained previously. Next we do a print statement, just since we want
to print out the flow of our program we need to add this at strategic places.</p>
<blockquote>
<p>One important thing to note here. Our <code>token</code> in this case is already guaranteed
to be unique. We generate it in the <code>Http</code> module (which is the only one registering
events by using this method in our example). The reason for this will become clear
in a few short chapters. Just note that we don't need to call <code>generate_cb_identity</code> here.</p>
</blockquote>
<p>We increase the counters on both <code>pending_events</code> and <code>epoll_pending_events</code>.</p>
<p>Our next method registers work for the thread pool</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn register_event_threadpool(
    &amp;mut self,
    task: impl Fn() -&gt; Js + Send + 'static,
    kind: ThreadPoolTaskKind,
    cb: impl FnOnce(Js) + 'static,
) {
    let callback_id = self.generate_cb_identity();
    self.add_callback(callback_id, cb);

    let event = Task {
        task: Box::new(task),
        callback_id,
        kind,
    };

    // we are not going to implement a real scheduler here, just a LIFO queue
    let available = self.get_available_thread();
    self.thread_pool[available].sender.send(event).expect(&quot;register work&quot;);
    self.pending_events += 1;
}
#}</code></pre></pre>
<p>Let's first have a look at the arguments to this function (aside from <code>&amp;mut self</code>).</p>
<p><code>task: impl Fn() -&gt; Js + Send + 'static</code> is a task we want to run on a separate
thread. This closure has the bond: <code>Fn() -&gt; Js + Send + 'static</code> which means
it's a <code>closure</code> that takes no arguments, but returns a type of <code>Js</code>. It needs to
be <code>'Send</code> since we're sending this task to another thread.</p>
<p><code>kind: ThreadPoolTaskKind</code> lets us know what kind of task this. We do this for
two reasons:</p>
<ol>
<li>We need to be able to signal a <code>Close</code> event to our threads</li>
<li>We want to be able to print the kind of task each event received.</li>
</ol>
<p>As you understand, we don't have to create a <code>Kind</code> for every task, but since we
want to print out what the thread received we need some way of judging what kind
of task each thread received.</p>
<p>The last argument <code>cb: impl FnOnce(Js) + 'static</code> is our callback. It's not a coincidence
that our <code>task</code> returns a type of <code>Js</code> and our callback takes a <code>Js</code> as an argument. The
result of the work we do in our thread is the input to our callback. This closure doesn't
need to be <code>Send</code> since we don't pass the callback itself to the thread pool.</p>
<p>Next we generate a new identity with <code>self.generate_cb_identity()</code> and we add the
callback to our callback queue.</p>
<p>Then we construct a new <code>Event</code>, and as I have shown earlier, we need to <code>Box</code> the
closure.</p>
<p>Now, the last part could be made arbitrarily complex. This is where you decide how
you want to schedule your work to the thread pool. In our case we just get an
available thread (and <code>panic!</code> if we're out of thread - ouch), and we send our task
to the thread which then runs it until it's finished.</p>
<p>You could make priorities based on <code>TaskKind</code>, you could try to decide which tasks
are short and which are long and prioritize them based on load. A lot of exiting
stuff could be done here. We will choose the simplest possible one though and just
push them directly to a thread in the order they come.</p>
<p>The last part of the &quot;infrastructure&quot; is a function to set a timeout. </p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn set_timeout(&amp;mut self, ms: u64, cb: impl Fn(Js) + 'static) {
        // Is it theoretically possible to get two equal instants? If so we'll have a bug...
        let now = Instant::now();
        let cb_id = self.generate_cb_identity();
        self.add_callback(cb_id, cb);
        let timeout = now + Duration::from_millis(ms);
        self.timers.insert(timeout, cb_id);
        self.pending_events += 1;
        print(format!(&quot;Registered timer event id: {}&quot;, cb_id));
    }
#}</code></pre></pre>
<p>Set timeout uses <code>std::time::Instant</code> to get a representation of &quot;now&quot;. It's the first
thing we do since the user expects the timeout to be calculated from &quot;now&quot;, and some
of our operations here might take a little time.</p>
<p>We generate an identity for the callback <code>cb</code> passed in to <code>set_timeout</code> and add
that callback to our callback queue.</p>
<p>We add the <code>duration</code> in milliseconds to our <code>Instant</code> so we know at what time
our timeout times out.</p>
<p>We insert the <code>callback_id</code> instant to our <code>BtreeMap</code> with the calculated <code>Instant</code> as
the key.</p>
<p>We increase the counter for <code>pending_events</code> and print out a message for us to
be able to follow the flow of our program.</p>
<blockquote>
<p>This might be a good time to talk briefly about our choice of a <code>BTreeMap</code> as
the collection we store timers in.</p>
<p>From the documentation we can read <em>&quot;In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log2n).&quot;</em>
Now, this isn't a Binary Tree but a BTree. While a BST allocates one node for each value, a BTree allocates
a small <code>Vec</code> of values for each node. Modern computers reads much more data than we normally ask for
into its caches, and thats one reason they love contagious parts of memory. A BTree will result in
a more optimal &quot;cache efficiency&quot; which often trumps the gains of the theoretically more optimal
algorithm in a true BST.</p>
<p>Lastly, since we're talking about searching sorted collections here, and timeouts, is a perfect example
of such, we'll of course use this when it's so readily available to us in Rusts standard library.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="8_8_cleaning_up.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="9_0_modules.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="8_8_cleaning_up.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="9_0_modules.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-149686420-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
