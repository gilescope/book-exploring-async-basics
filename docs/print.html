<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Investigating Async Basics - Implementing the Node.js Eventloop in Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="1_what_is_async.html"><strong aria-hidden="true">1.</strong> What is async?</a></li><li><a href="2_async_history.html"><strong aria-hidden="true">2.</strong> Async history</a></li><li><a href="3_the_operating_system.html"><strong aria-hidden="true">3.</strong> The Operating System and CPU</a></li><li><a href="4_interrupts_firmware_io.html"><strong aria-hidden="true">4.</strong> Interrupts, Firmware and I/O</a></li><li><a href="5_strategies_for_handling_io.html"><strong aria-hidden="true">5.</strong> Strategies for handling I/O</a></li><li><a href="6_0_implementing_the_node_eventloop.html"><strong aria-hidden="true">6.</strong> Implementing the Node Eventloop</a></li><li><ol class="section"><li><a href="6_1_what_is_node.html"><strong aria-hidden="true">6.1.</strong> What is Node?</a></li><li><a href="6_2_node_whats_our_plan.html"><strong aria-hidden="true">6.2.</strong> What's our plan</a></li><li><a href="6_3_node_the_main_loop.html"><strong aria-hidden="true">6.3.</strong> The main loop</a></li><li><a href="6_4_node_the_threadpool.html"><strong aria-hidden="true">6.4.</strong> The threadpool</a></li><li><a href="6_5_node_the_io_eventqueue.html"><strong aria-hidden="true">6.5.</strong> The I/O eventqueue</a></li><li><a href="6_6_node_final_code.html"><strong aria-hidden="true">6.6.</strong> Final code</a></li></ol></li><li><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Investigating Async Basics - Implementing the Node.js Eventloop in Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This book is part of a series investigating several aspects and methods of handling async code execution:</p>
<ul>
<li><a href="https://app.gitbook.com/@cfsamson/s/green-threads-explained-in-200-lines-of-rust/">Green threads explained in 200 lines of Rust</a></li>
<li>Investigating Async Basics by Implementing the Node.js Eventloop in Rust (The book you're reading now)</li>
<li>Investigating Epoll, Kqueue and IOCP with Rust (Will be released October 2. 2019)</li>
<li>Investigating Rusts Futures (TBD)</li>
</ul>
<p>Our main goal is to get a solid understanding of the inner secrets of Async code, using that knowledge to demystify Rusts Futures evolving async story.</p>
<h2><a class="header" href="#what-well-do" id="what-well-do">What we'll do</a></h2>
<ul>
<li>Go through the basics of asynchronous code execution, some history and basic definitions</li>
<li>Be very precise and define the difference between async and parallel</li>
<li>Talk about how the Operating System and the CPU in regards to I/O and async</li>
<li>Dig into how interrupts, scheduling, firmware and threads relate to our subject</li>
<li>Go through different methods of handling async, like green threads, threadpools and event queues</li>
<li>Look at how Nodes eventloop works and how it manages to be so efficient in execution async code</li>
<li>Implement our own working toy version of the Node.js eventloop using our knowledge</li>
</ul>
<h2><a class="header" href="#external-dependencies" id="external-dependencies">External dependencies</a></h2>
<p>We will only rely in the standard library for this, making sure that we understand everything and leave no gaps uncovered. While this is a pretty big constraint when using Rust it does require us to answer certain basic questions that would otherwise go unasked.</p>
<p>For this to work I had to make a library for the cross platform epoll/kqueue/IOCP eventloop that is explained in depth in the next book.</p>
<h2><a class="header" href="#disclaimer" id="disclaimer">Disclaimer</a></h2>
<ul>
<li>We'll implement a <strong>toy</strong> version of the Node.js eventloop (a bad, but working and conceptually similar eventloop)</li>
<li>We'll not primarily focus on code quality and safety, though this is important, we want to understand the concepts and ideas behind the code. We will have to take many shortcuts to keep this concise and short. If we don't we end up reimplementing <code>libuv</code> at some point :)</li>
<li>I will however do my best to point out hazards and the shortcuts we make. I will try to point out obvious places we could do a better job, and I will not use <code>unsafe</code> needlessly unless there is a very good reason to do it.</li>
<li>The book(s) you're reading is the result of a few hundred hours of investigations. I will not claim expertise beyond that, but I will guarantee that I try to verify all the information from more than one source unless it's directly from official documentation.</li>
</ul>
<h2><a class="header" href="#why-i-write-this" id="why-i-write-this">Why I write this</a></h2>
<p>I'm curious, and I really hate the feeling of having big gaps in my understanding of a subject. I initially wanted to write a short article about async code and tie it in to Rust Futures. As I started digging and uncover the gaps I had, that idea for an article have expanded into 4 small books on the subject.</p>
<p>Now, some of this information and insight is hard to come by, so I write it down in these books and share my findings with everyone else. I hope you find it as interesting as me.</p>
<h1><a class="header" href="#what-is-asynchronous-code-execution-and-concurrency" id="what-is-asynchronous-code-execution-and-concurrency">What is asynchronous code execution and concurrency?</a></h1>
<p>Composition of independently executed processes.</p>
<p>Concurrency is about <strong>dealing</strong> with a lot of things at the same time. </p>
<p>Parralellism is about <strong>doing</strong> a lot of things at the same time.</p>
<p>We handle concurrency by executing tasks/processes in an asynchronous manner. Asynchronous code execution is therefore the 
way we handle concurrency in programming.</p>
<h2><a class="header" href="#the-mental-model-i-use" id="the-mental-model-i-use">The mental model I use.</a></h2>
<p>I firmly believe the main reason we find parallel and concurrent programming hard to reason about is that it's very easy to 
confuse parallel execution with concurrent execution. I think that most of this confusion stems from how we tend to 
model events in our everyday life. We tend to not define these terms very precise so our intuition 
is often wrong.</p>
<p><strong>Let's model our world with these simple rules:</strong></p>
<ol>
<li>Everything you do requires resources</li>
<li>Resources are limited</li>
<li>Timing is important</li>
<li>Our main purpose is to use resources as efficiently as possible</li>
<li>Waiting is wasting resources</li>
<li>We don't have enough resources</li>
</ol>
<p>Now, all of these need to be true for concurrency to even matter, but this is true from on perspective or another more often than you'd think.</p>
<h3><a class="header" href="#parallelism" id="parallelism">Parallelism</a></h3>
<p>Is increasing the resources we use to solve a task. It has nothing to do with efficiency.</p>
<h3><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h3>
<p>Has everything to do with efficiency and resource utilization. Concurrency can never make <em>one single task go faster</em>. 
It can only help us utilize our resources better and thereby <em>finish a set of tasks faster</em>.</p>
<h3><a class="header" href="#lets-draw-some-parallels-to-process-economics" id="lets-draw-some-parallels-to-process-economics">Let's draw some parallels to process economics</a></h3>
<p>In businesses that manufacture goods, we often talk about LEAN processes. And this is pretty easy to compare with what concurrency
does for programmers. I'll let let this 3 minute video explain it for me:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Oz8BR5Lflzg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Now would adding more resources (more workers) help in this case? Yes, but we use double the resources to produce the 
same output as 1 person with a optimal process could do. That's not optimal utilization of our resources.</p>
<p>If you consider the coffee machine as some I/O resource we would like to start that process, and move on to preparing the 
next job, or do other work that needs to be done instead of waiting.</p>
<p>But that means there are things happening in parallel here? Yes, the coffee machine is doing work while the &quot;worker&quot; is doing
maintenance and filling water. But this is the crux: Our reference frame is the worker, not the whole system. The worker
is doing things concurrently. The guy making coffee (the worker) is your code. </p>
<p><strong>Concurrency is about working smarter and harder. Parallelism is throwing more resources at the problem</strong></p>
<h3><a class="header" href="#what-about-threads" id="what-about-threads">What about threads</a></h3>
<p>We'll cover threads a bit more when we talk about operating systems, but I'll mention them here as well. The problem with
threads provided by the operating system is that they appear to be mapped to cores. But that is not neccicarely the truth even 
though most operating systems will try to map one thread to a core up to the number of threads is equal to  the number of cores.</p>
<p>Once we create more threads than there are cores, the OS will switch between our threads and progress each of them concurrently
using the scheduler to give each thread some time to run. So in this way, threads can be a means to achieve parallelism, but 
they can also be a means to achieve concurrency. Now if you find that confusing, I understand. There is a reason why this is 
hard to understand. </p>
<p>But it's a good time to talk about changing the reference frame.</p>
<h3><a class="header" href="#changing-the-reference-frame" id="changing-the-reference-frame">Changing the reference frame</a></h3>
<p>When you write code that is perfectly synchronous from your perspective, let's take a look at how that looks from the operating
system perspective.</p>
<p>The Operating System might not run your code from start to end at all. It might stop and resume your process many times. 
The CPU might get interrupted and handle som inputs while you think it's only focused on your task. So synchronous execution is
only an illusion. But from the perspective of you as a programmer it's not, and that is the important takeaway:</p>
<p>When we talk about concurrency without providing any other context we are using you as a programmer and your code 
(your process) as the reference frame.</p>
<p>The reason I spend so much time on this is that once you realize that, you'll start to see that some of the things you hear and
learn that might seem contradictionary is not. You'll have to consider the reference frame first.</p>
<p>If this sounds complicated, I promise that we'll get to see and know this better as we go on. So if you found this confusing, relax
this will become clearer as we go on.</p>
<h2><a class="header" href="#lets-finish-up-this-chapter-with-some-definitions" id="lets-finish-up-this-chapter-with-some-definitions">Lets finish up this chapter with some definitions</a></h2>
<p>We can derive some definitions from all above paragraphs that will help us going forward:</p>
<h3><a class="header" href="#resource" id="resource">Resource:</a></h3>
<p>Something needed to perform work on a task. We have limited amounts of resources.</p>
<h3><a class="header" href="#performing-a-task" id="performing-a-task">Performing a task:</a></h3>
<p>For this to have any meaning we'll have to define this as work that requires some kind of resource, whether it's computational power 
from the CPU or it's your brain processing something. </p>
<h3><a class="header" href="#parallel" id="parallel">Parallel:</a></h3>
<p>Something happening at the <strong>exact</strong> same time that requires some limited resource to happen.</p>
<h3><a class="header" href="#concurrent" id="concurrent">Concurrent:</a></h3>
<p>The ability to stop and resume a task. This means that we have more options when deciding how our limited resources are spent over time. 
This enable us to respond to external events, change priorities or share resources more efficiently (or fairly).</p>
<h3><a class="header" href="#reference-frame" id="reference-frame">Reference frame</a></h3>
<p>Concurrency needs to have a frame of reference to have any meaning.</p>
<h1><a class="header" href="#for-example-from-in-the-context-of-your-brain-talking-on-the-phone-is-not-a-task-when" id="for-example-from-in-the-context-of-your-brain-talking-on-the-phone-is-not-a-task-when">For example, from in the context of your brain, talking on the phone is not a task when:</a></h1>
<h1><a class="header" href="#1-you-hold-the-phone-to-your-ear-and-there-is-silence-or-in-between-ring-tones-when-waiting-for-someone-to-pick-up" id="1-you-hold-the-phone-to-your-ear-and-there-is-silence-or-in-between-ring-tones-when-waiting-for-someone-to-pick-up">1. You hold the phone to your ear and there is silence or in between ring tones when waiting for someone to pick up</a></h1>
<h1><a class="header" href="#2-when-there-are-silences-or-breaks-in-between-sentences-or-for-some-other-reason" id="2-when-there-are-silences-or-breaks-in-between-sentences-or-for-some-other-reason">2. When there are silences or breaks in between sentences or for some other reason</a></h1>
<h1><a class="header" href="#3-if-youre-not-actively-listening-or-talking" id="3-if-youre-not-actively-listening-or-talking">3. If you're not actively listening or talking</a></h1>
<h1><a class="header" href="#" id=""></a></h1>
<h1><a class="header" href="#now-a-very-efficient-person-can-do-some-other-work-while-waiting-on-the-phone-for-someone-to-pick-up-as-long-as-that-task-is" id="now-a-very-efficient-person-can-do-some-other-work-while-waiting-on-the-phone-for-someone-to-pick-up-as-long-as-that-task-is">Now a very efficient person can do some other work while waiting on the phone for someone to pick up, as long as that task is</a></h1>
<h1><a class="header" href="#quick-to-stop-and-resume-later-on-short-notice-there-might-even-be-reason-to-do-some-tasks-while-on-the-phone-if-you-can-context" id="quick-to-stop-and-resume-later-on-short-notice-there-might-even-be-reason-to-do-some-tasks-while-on-the-phone-if-you-can-context">quick to stop and resume later on short notice. There might even be reason to do some tasks while on the phone if you can context</a></h1>
<h1><a class="header" href="#switch-good-enough-but-even-though-we-tend-to-say-we-do-this-i-parallel-we-dont-we-just-pause-and-resume-tasks-very-quickly" id="switch-good-enough-but-even-though-we-tend-to-say-we-do-this-i-parallel-we-dont-we-just-pause-and-resume-tasks-very-quickly">switch good enough. But even though we tend to say we do this i parallel we don't, we just pause and resume tasks very quickly.</a></h1>
<h1><a class="header" href="#-1" id="-1"></a></h1>
<h1><a class="header" href="#from-the-perspective-of-you-physical-body" id="from-the-perspective-of-you-physical-body">From the perspective of you physical body:</a></h1>
<h1><a class="header" href="#1-youre-on-the-phone-as-long-as-you-hold-your-phone-to-your-ear" id="1-youre-on-the-phone-as-long-as-you-hold-your-phone-to-your-ear">1. You're on the phone as long as you hold your phone to your ear</a></h1>
<h1><a class="header" href="#2-being-on-the-phone-uses-some-of-limited-resources-12-arms" id="2-being-on-the-phone-uses-some-of-limited-resources-12-arms">2. Being on the phone uses some of limited resources (1/2 arms)</a></h1>
<h1><a class="header" href="#3" id="3">3.</a></h1>
<h1><a class="header" href="#async-history" id="async-history">Async history</a></h1>
<p>In the beginning.
Everything was synchronous. Computers had one CPU and it executed a piece of code written by a programmer and then returned. No scheduling, no threads, no multitasking. We're talking back when the days where a program looked like this:</p>
<p><img src="./images/punched_card_deck.jpg" alt="Image" /></p>
<p>There were operating systems though, and when personal computing started to grow in the 80's we had operating systems like DOS, but they usually yielded control of the entire CPU to the program (and the programmer) that was currently running.
This worked fine, but as interactive UI's using a mouse and windowed operating systems became the norm, this simply couldn't work anymore.</p>
<h2><a class="header" href="#hyperthreading" id="hyperthreading">Hyperthreading</a></h2>
<p>As CPU's evolved and added more functionality like several ALUs (Algorithmic Logical Unit) and more logical units in general, the CPU manufacturers realized that the entire CPU was never utilitized fully. For example when an operation only required some parts of the CPU, an instruction could be run on the ALU simultainiously. This became the start of Hyperthreading.Â¨</p>
<p>You see, on your computer today that it has i.e. 6 cores, and 12 logical cores. This is exactly where Hyperthreading comes in. It &quot;simulates&quot; two cores on the same core by using unused parts of the CPU to drive progress on thread &quot;2&quot; simultainiously as it's running the code on thread &quot;1&quot; by using a number of smart tricks (like the one with the ALU). Now we could actually offload some work on one thread while keeping the UI interactive by responding to events in the second thread event though we only have one CPU core.</p>
<p>You might wonder how this is really different from multicore processors? What about performance? I turns out that Hyperthreading has been improved since the 90's all the time. Since you're not actually running two CPU's there will be some operations that need to wait for each other to finish, and how much of a penalty this gives compared to two seperate cores might depend a bit on exactly what the code is doing, but the numbers I have seen shows &quot;only&quot; a 30 % penalty comparted to two seperate CPU's. In other words, it's pretty good!</p>
<h2><a class="header" href="#non-preemptive-multitasking" id="non-preemptive-multitasking">Non-preemptive multitasking</a></h2>
<p>The method used to be able to keep the UI interactive and running background processes, was accomplished by non-preemtive multitasking. This kind of multitasking put the responsibility of letting the OS run other tasks like responding to input from the mouse, or running a background task in the hands of the programmer. Typically the programmeryieldedcontrol to the OS.</p>
<p>Beside offloading a huge responsibility to every programmer writing a program for your platform, this was also error prone. A small mistake in a programs code could halt or crash the entire system. If you remember Windows 95, you also remember the times when a window hung and you could paint the entire screen with it (almost the same way as the end in Solitare, the card game that came with Windows). This was a typical error in the code that was supposed to yield control to the operating system.</p>
<p>If you're not sure about what this is I can recommend my previous book that explains this part of multitasking pretty well. You'll know everything you need about threads, contexts, stacks and scheduling for following along.</p>
<h2><a class="header" href="#preemtive-multitasking" id="preemtive-multitasking">Preemtive multitasking</a></h2>
<p>While non-preemtive multitasking sounded like a good idea, it turned out to create serious problems as well. I will not list them here but as you can imagine, letting every program and programmer out there be responsible for parts of the scheduling of tasks in an operating system will be chaos and ultimately lead to a bad user experience.
So they put the responsibility of scheduling the CPU resources between the programs that requested it (including to OS itself) in the hands of the OS. The OS can stop execution of a process, do something else, and switch back.</p>
<p>In a single core machine you can visualize this as running a program you wrote, and the OS stops to update the mouse position, and witches back to your program. This can happen many times each second, not only to keep the UI responsive but it can also give some time to other background tasks and IO events.</p>
<p>This is now the prevailing way to design an operating system. </p>
<h2><a class="header" href="#so-how-synchronous-is-the-code-you-write-really-" id="so-how-synchronous-is-the-code-you-write-really-">So how synchronous is the code you write, really ?</a></h2>
<p>As many things this depends on your perspective. From the perspective of the code you write, and you as a programmer, everything will happen in the order you write it.
From the OS perspective it might, or might not, interrupt your code, pause it and run some other code in the meantime before resuming. 
From the perspective of the CPU it will mostly execute* instructions one at a time. They don't care who wrote the code though so when a hardware interrupt happens, they will immediately stop and give control to an interrupt handler, so the CPU doesn't have any concept of asynchronous execution.</p>
<p>However, modern CPU can also do a lot if things in parallel. Most CPUs are pipelined, meaning that the next instruction is loaded while the current is executing. It might have a branch predictor that tries to figure out what instructions to load next. The processor can also reorder instructions by using &quot;out of order execution&quot; if it believes it makes things faster this way without &quot;asking&quot; or &quot;telling&quot; the programmer or the OS so you might not have any guarantee that A happens before B. The CPU offloads some work to separate &quot;coprocessors&quot; like the FPU for for floating point calculations leaving the main CPU ready to do other tasks et cetera.
*As a high level overview, it's OK to model the CPU as operating in a synchronous manner, but lets for now just make a mental note that this is a model with a ton caveats that becomes especially important when talking about parallelism, synchronization primitives like mutexes and atomics and security.</p>
<h1><a class="header" href="#the-operating-system" id="the-operating-system">The Operating System</a></h1>
<p>The operating system stands in the center of everything we do as programmers, so there is no way for us to discuss any kind 
of fundamentals in programming without talking about operating systems in a bit of detail.</p>
<h2><a class="header" href="#communicating-with-the-operating-system" id="communicating-with-the-operating-system">Communicating with the operating system</a></h2>
<p>Communication with the operating system is done through <code>System Calls</code> or &quot;syscalls&quot;, this is a public API that the 
operating system provides for applications to work. Most of the time these calls are abstracted away for us as programmers 
by the language or the runtime we use. A language like Rust makes it trivial to make a syscall though which we will see below.</p>
<p>Now syscalls is an example of something that is absolutely non-portable, but often (not always) BSD-family operating systems 
uses the same syscalls as Linux-family of operating system. Often these are referred to as UNIX family of operating systems.</p>
<p>Windows on the other hand has nothing in common with the UNIX family and uses it's own api, often referred to as WinAPI.</p>
<h3><a class="header" href="#syscall-example" id="syscall-example">Syscall example</a></h3>
<p>To get a bit more familiar with syscalls we'll implement a very basic one for the three arcitectures: BSD(macos), Linux and Windows.</p>
<p>The syscall we'll implement is the one used when we write something to <code>stdout</code> since that is such a common operation it's interesting to 
se how it really works:</p>
<p>Fortunately for us in this specific example, the syscall is the same on Linux and on Macos so we only need to worry if we're on 
Windows and therefore use the <code>#[cfg(not(target_os = &quot;windows&quot;))]</code> conditional compilation flag. For the Windows syscall we do the opposite.</p>
<h4><a class="header" href="#a-cross-platform-write-syscall" id="a-cross-platform-write-syscall">A cross platform Write syscall</a></h4>
<p>You can run this directly here and see it work, but since the Rust playground runs on Linux, you'll need to copy the code over to
a windows machine if you want to try it out.</p>
<pre><pre class="playpen"><code class="language-rust">use std::io;

fn main() {
    let sys_message = String::from(&quot;Hello world from syscall!\n&quot;);
    syscall(sys_message).unwrap();
}

// ===== WRITE SYSCALL ON LINUX/MACOS ======

// and: http://man7.org/linux/man-pages/man2/write.2.html
#[cfg(not(target_os = &quot;windows&quot;))]
#[link(name = &quot;c&quot;)]
extern &quot;C&quot; {
    fn write(fd: u32, buf: *const u8, count: usize) -&gt; i32;
}

#[cfg(not(target_os = &quot;windows&quot;))]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    let res = unsafe { write(1, msg_ptr, len) };

    if res == -1 {
        return Err(io::Error::last_os_error());
    }
    Ok(())
}

// ===== WRITE SYSCALL ON WINDOWS ======

#[cfg(target_os = &quot;windows&quot;)]
#[link(name = &quot;user32&quot;)]
extern &quot;stdcall&quot; {
    /// https://docs.microsoft.com/en-us/windows/console/getstdhandle
    fn GetStdHandle(nStdHandle: i32) -&gt; i32;
    /// https://docs.microsoft.com/en-us/windows/console/writeconsole
    fn WriteConsoleA(
        hConsoleOutput: i32,
        lpBuffer: *const u8,
        numberOfCharsToWrite: u32,
        lpNumberOfCharsWritten: *mut u32,
        lpReserved: *const std::ffi::c_void,
    ) -&gt; i32;
}

#[cfg(target_os = &quot;windows&quot;)]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    let mut output: u32 = 0;
        let handle = unsafe { GetStdHandle(-11) };
        if handle  == -1 {
            return Err(io::Error::last_os_error())
        }

        let res = unsafe { WriteConsoleA(handle, msg_ptr, len as u32, &amp;mut output, std::ptr::null()) };
        if res  == 0 {
            return Err(io::Error::last_os_error());
        }

    assert_eq!(output as usize, len);
    Ok(())
}

</code></pre></pre>
<p>I'll explain what we just did here. I assume that the <code>main</code> method needs no comment.</p>
<h4><a class="header" href="#linux-and-macos" id="linux-and-macos">Linux and Macos</a></h4>
<pre><code class="language-rust no_run noplaypen">#[link(name = &quot;c&quot;)]
</code></pre>
<p>Every Linux installation comes with a version of <code>libc</code> which a C-library for communicating 
with the operating system. Having a <code>libc</code> with a consistent API means they can change the underlying implementation without braking
everyones code. This flag tells the compiler to link to the &quot;c&quot; library on the system we're compiling for.</p>
<pre><code class="language-rust no_run noplaypen">extern &quot;C&quot; {
    fn write(fd: u32, buf: *const u8, count: usize);
}
</code></pre>
<p><code>extern &quot;C&quot;</code> or only <code>extern</code> (C is assumed if nothing is specified) means we're linking to specific functions in the &quot;c&quot; library using the &quot;C&quot; calling convention. As you'll see
on Windows we'll need to change this since it uses a different calling convention than the UNIX family.</p>
<p>The function we're linking to needs to have the exact same name, in this case <code>write</code>. The parameters doesn't need to have the same 
name but they must be in the right order and it's good practice to name them the same as in the library you're linking to.</p>
<p>The write function takes a <code>file descriptor</code> which in this case is a handle to <code>stdout</code>, a pointer to a array of <code>u8</code> values,
and a count of how many values we want to read from the buffer.</p>
<pre><code class="language-rust no_run noplaypen">#[cfg(not(target_os = &quot;windows&quot;))]
fn syscall_libc(message: String) {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    unsafe { write(1, msg_ptr, len) };
}
</code></pre>
<p>The first thing we do is to get the pointer to the underlying buffer for our string. That will be a pointer of type <code>*const u8</code>
which matches our <code>buf</code> argument. The length of the message corresponds to the <code>count</code> argument.</p>
<p>You might ask how we know that <code>1</code> is the file handle to <code>stdout</code> and where we found that value. You'll notice this a lot when writing syscalls from 
Rust. Usually constants are defined in the C header files which we can't link to, so we need to search them up. 1 is always the file descriptor for
<code>stdout</code> on UNIX systems.</p>
<p>A call to a FFI function is always unsafe so we need to use the <code>unsafe</code> keyword here.</p>
<p>Now for this simple example we'll only focus on the Unix family syscall. Don't worry, in the next book you'll get more than enough time
with syscalls on all of the three big platforms.</p>
<h2><a class="header" href="#about-writing-cross-platform-abstractions" id="about-writing-cross-platform-abstractions">About writing cross platform abstractions</a></h2>
<p>If you isolate the code needed only for Linux and Macos you'll see that it's not many lines of code to write. But once you
want to make a cross platform variant, the amount of code explodes. This is a problem when writing about this stuff in general,
but we need some basic understanding on how the different operating systems work under the covers. </p>
<p>My experience in general is that Linux and Macos have simpler
api's requiring fewer lines of code, and often (but not always) the exact same call works for both systems.</p>
<p>Windows on the other hand is mor complex, requires more &quot;magic&quot; constant numbers, requires you to set up more structures to pass in, 
and way more lines of code. What Windows does have though are very good documentation so even though it's more work you'll also 
find more official documentation.</p>
<h1><a class="header" href="#threads" id="threads">Threads</a></h1>
<p>Threads are one of the baisc constructs for running code that we programmers create. Like the syscall for outputting text to the console, 
there is a syscall for asking the OS to create a thread. </p>
<p>Now threads are a bit special, since they are the thing that actually makes us think that we write <strong>synchronous</strong> code at all.</p>
<p>Let's stop for a second and think a bit about the significance of threads for our the problem domain we're investigating here:</p>
<p>The &quot;naive&quot; way of thinking about your code is like this:</p>
<p>Now threads</p>
<p>memory</p>
<p>faking sync</p>
<p>I find it easy to forget is that everything I do goes through the operating system. Of course I know it's there, .</p>
<p>When we ask for memory, like if we call <code>let my_vec = vec![0_u8;1040]</code> we actually ask the OS to map some memory for us and hand it over. </p>
<p>Have you ever wondered how you can write plain assembly, which pretty much is CPU instructions, and execute them, but still get an error if you try to access memory that is not mapped to you?</p>
<p>Let's say you execute the following code:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(asm)]
fn main() {
    let t = 100;
    let x = dereference(&amp;t);
    
    println!(&quot;{}&quot;, x);
}

fn dereference(ptr: *const usize) -&gt; usize {
    let res: usize;
    unsafe {
    // Note: the parenthesis around ($1) means that we want to get the value at 
    // the memory location which $1 is pointing at
    asm!(&quot;mov ($1), $0&quot;:&quot;=r&quot;(res): &quot;r&quot;(ptr));
    }
 
    res
}
</code></pre></pre>
<p>As you see, this code will output <code>100</code> as expected. But let's instead create a pointer with the address <code>9999999</code> which
we know just points somewhere random and see what happens when we pass that into the same function:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(asm)]
fn main() {
    let t = 9999999 as *const usize;
    let x = dereference(t);
    
    println!(&quot;{}&quot;, x);
}
#
# fn dereference(ptr: *const usize) -&gt; usize {
#     let res: usize;
#     unsafe {
#     asm!(&quot;mov ($1), $0&quot;:&quot;=r&quot;(res): &quot;r&quot;(ptr));
#     }
#  
#     res
# }
</code></pre></pre>
<p>Now we get a segmentation fault. Not very surprising, and a complicated way of dereferencing a pointer but I wanted to stress 
that we're &quot;talking&quot; directly with the CPU here. There are no checks in Rust, no syscalls or anything happening behind the 
scenes that alerst the OS that we try to access memory we shouldn't access. So how does the CPU know that we can't access this memory location?</p>
<p>This is a sure hint that the CPU does indeed operate in tandem with the operating system, we ask the operating system to map some
memory for us, and somehow the CPU (MMU) know what memory we can access and not.</p>
<h1><a class="header" href="#bonus-section" id="bonus-section">Bonus section</a></h1>
<p>So how does the CPU know that we don't have access to the memory referenced in the example above?</p>
<p>Most CPU's ca run in different memory protection levels.</p>
<h1><a class="header" href="#interrupts-firmware-and-io" id="interrupts-firmware-and-io">Interrupts, Firmware and I/O</a></h1>
<h1><a class="header" href="#strategies-for-handling-io" id="strategies-for-handling-io">Strategies for handling I/O</a></h1>
<h1><a class="header" href="#implementing-the-node-eventloop" id="implementing-the-node-eventloop">Implementing the Node Eventloop</a></h1>
<h1><a class="header" href="#what-is-node" id="what-is-node">What is Node?</a></h1>
<h1><a class="header" href="#whats-our-plan" id="whats-our-plan">What's our plan</a></h1>
<h1><a class="header" href="#the-main-loop" id="the-main-loop">The main loop</a></h1>
<h1><a class="header" href="#the-threadpool" id="the-threadpool">The threadpool</a></h1>
<h1><a class="header" href="#the-io-eventqueue" id="the-io-eventqueue">The I/O eventqueue</a></h1>
<h1><a class="header" href="#final-code" id="final-code">Final code</a></h1>
<h1><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
